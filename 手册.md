>wapper翻译为包装
>burst翻译为突发
>assert翻译为激活
>increment翻译为递增
>beat翻译为拍

# 第一章 介绍

## 1.1关于AXI总线
AMBA AXI 协议是为高性能、高频率的系统设计所定制的，它具备一系列特性，使其成为高速次微米级互连的理想选择。最新一代的 AMBA 接口旨在：

-   适合高带宽和低延迟的设计
-   在不需要复杂桥接的情况下实现高频操作
-   满足各种组件的接口需求
-   适合初次访问延迟较高的内存控制器
-   在实现互连架构时提供灵活性
-   向后兼容现有的 AHB 和 APB 接口。

## 1.2主要特征
AXI 协议的主要特性包括：

-   将地址/控制与数据阶段分开处理
-   支持通过字节选通实现非对齐数据的传输
-   事务以突发为基础，仅需发出开始地址
-   通过分开读写数据通道，可以实现低成本的直接内存访问（DMA）
-   可以发出多个尚未完成的地址multiple outstanding addresses
-   事务可以无序完成out-of-order
-   可以轻松地添加寄存器阶段以实现时序闭环timing closure。

除了数据传输协议之外，AXI 协议还包括一些可选的扩展，这些扩展涵盖了低功耗操作的信号。

AXI 协议是基于突发模式的。**每个事务在地址通道上都会有地址和控制信息**，这些信息描述了将要传输的数据的性质。数据通过写数据通道传输到从设备，或通过读数据通道传输到主设备。在写事务中，所有的数据都从主设备流向从设备，AXI 协议提供了一个额外的写响应通道，允许从设备向主设备反馈写事务已经完成。AXI 协议使得：

-   在实际数据传输之前就发出地址信息
-   支持多个尚未完成的事务
-   支持事务的无序完成。  

• address information to be issued ahead of the actual data transfer  
• support for multiple outstanding transactions  
• support for out-of-order completion of transactions.


    图 1-1 展示了读取事务如何利用读地址和读数据通道。

![[1-1.jpg]]
    图 1-2 在第 1-4 页展示了写事务如何利用写地址、写数据以及写响应通道。
![[1-2.jpg]]

### 1.2.1 通道定义(Channel definition)

每一个独立的五个通道都包含一组信息信号，并使用双向的 `VALID` 和 `READY` 握手机制。信息源使用 `VALID` 信号来显示何时在通道上可用有效的数据或控制信息。目的地使用 `READY` 信号来显示何时可以接受数据。读取数据通道和写入数据通道还包括一个 `LAST` 信号，用于指示事务中最后一个数据项的传输何时发生。

#### 读取和写入地址通道(Read and write address channels)

读取和写入事务各自有自己的地址通道。相应的地址通道承载了事务所需的所有地址和控制信息。AXI协议支持以下机制：

-   可变长度的突发，从1到16个数据传输每次突发
-   突发传输大小为8-1024位
-   包装，递增和非递增突发wrapping, incrementing, and non-incrementing burst
-   使用独占或锁定访问的原子操作
-   系统级缓存和缓冲控制
-   安全和特权访问。

#### 读数据通道(Read data channel)

读数据通道传输从从设备（slave）返回到主设备（master）的读取数据和任何读取响应信息。读数据通道包括：

-   数据总线，可以是8，16，32，64，128，256，512或1024位宽
-   表示读取事务完成状态的读取响应。

#### 写数据通道(Write data channel)

写数据通道传输从主设备（master）到从设备（slave）的写入数据，并包括：

-   数据总线，可以是8，16，32，64，128，256，512或1024位宽
-   每八个数据位有一个字节通道选通，指示数据总线的哪些字节是有效的。

写数据通道的信息总是被视为缓冲的，以便主设备可以执行写入事务，而无需从设备对先前的写入事务进行确认。

#### 写响应通道(Write response channel)

写响应通道为从设备响应写入事务提供了一种方式。所有写入事务都使用完成信号。

完成信号在每次突发中只发生一次，而不是在突发中的每个单独数据传输中发生。

### 1.2.2 接口和互连(Interface and interconnect)
![[1-3.jpg]]
典型的系统由许多主设备和从设备组成，通过某种形式的互连连接在一起，如图1-3所示。AXI协议为描述接口提供了单一的接口定义：

-   主设备和互连之间
-   从设备和互连之间
-   主设备和从设备之间。

接口定义使得可以实现各种不同的互连实现。设备间的互连相当于另一种设备，具有对称的主端口和从端口，可以连接实际的主设备和从设备。

大多数系统使用以下三种互连方法之一：

-   共享地址和数据总线
-   共享地址总线和多个数据总线
-   多层，具有多个地址和数据总线。

在大多数系统中，地址通道的带宽需求明显低于数据通道的带宽需求。这样的系统通过使用共享地址总线和多个数据总线来实现并行数据传输，可以在系统性能和互连复杂性之间达到良好的平衡。

### 1.2.3 寄存器切片(Register slices)

每个AXI通道只在一个方向上传输信息，并且各个通道之间没有固定关系的要求。这一点很重要，因为它使得可以在任何通道中插入一个寄存器切片，代价是增加一个周期的延迟。这使得可以在延迟周期和操作的最大频率之间进行权衡。

也可以在给定的互连中的几乎任何点使用寄存器切片。在处理器和高性能内存之间使用直接的、快速的连接可能是有利的，但是使用简单的寄存器切片隔离到性能不那么关键的外设的更长路径可能是有利的。

## 1.3 基本事务(Basic transactions)

本节给出了基本的AXI协议事务示例。每个示例都显示了VALID和READY的握手机制。当VALID和READY信号都为HIGH时，会发生地址信息或数据的传输。这些示例包括：

-   读取突发示例
-   第1-8页的重叠读取突发示例
-   第1-9页的写入突发示例。

本节还描述了第1-9页的事务排序。

### 1.3.1 读取突发示例(Read burst example)

图1-4展示了一个四次传输的读取突发。在此示例中，主设备驱动地址，从设备在一个周期后接受它。

注意：主设备还驱动一组显示突发长度和类型的控制信号，但是为了清晰起见，这些信号在图中被省略。

在地址出现在地址总线上之后，数据传输发生在读取数据通道上。从设备在读取数据可用之前，保持VALID信号为LOW。对于突发的最后一次数据传输，从设备激活RLAST信号，以显示正在传输最后一个数据项。
![[1-4.jpg]]

### 1.3.2 重叠读取突发示例(Overlapping read burst example)

图1-5显示了主设备如何在从设备接受第一个地址后驱动另一个突发地址。这使得从设备能够在完成第一次突发的同时并行处理第二次突发的数据。

![[1-5.jpg]]

### 1.3.3 写入突发示例(Write burst example)

图1-6显示了一个写入事务。过程开始于主设备在写入地址通道上发送地址和控制信息。然后，主设备在写入数据通道上发送每个写入数据项。当主设备发送最后一个数据项时，WLAST信号变为HIGH。当从设备接受了所有的数据项时，它向主设备驱动一个写入响应，以指示写入事务已完成。

![[1-6.jpg]]


### 1.3.4 事务排序(Transaction ordering)

AXI协议支持无序事务完成。它给接口上的每个事务分配一个ID标签。**协议要求具有相同ID标签的事务按顺序完成，但是具有不同ID标签的事务可以无序完成**。

无序事务可以通过两种方式提高系统性能：

-   互连可以使得与快速响应的从设备的事务优先于与较慢的从设备的早期事务完成。
-   复杂的从设备可以无序返回读取数据。例如，稍后访问的数据项可能在内部缓冲区中可用，而早期访问的数据还未可用。

**如果主设备要求按照发出的顺序完成事务，那么它们必须都有相同的ID标签**。然而，如果主设备不要求按顺序完成事务，它可以为事务提供不同的ID标签，使它们可以按任何顺序完成。

`在多主设备系统中，互连负责向ID标签添加额外信息，以确保所有主设备的ID标签都是唯一的`。ID标签类似于主设备号，但是每个主设备可以通过提供ID标签来在同一端口内实现多个虚拟主设备，以指示虚拟主设备号。

尽管复杂的设备可以使用无序设施，但是简单的设备不需要使用它。简单的主设备可以为每个事务发出相同的ID标签，简单的从设备可以按顺序响应每个事务，不考虑ID标签。

## 1.4 附加特性(Additional features)

AXI协议还支持以下附加特性：

**突发类型(Burst types)**  
AXI协议支持三种不同的突发类型，适用于：

-   正常的内存访问
-   缓存线突发包装
-   将数据流式传输到外设FIFO位置。  
    请参见第4章地址选项。

**系统缓存支持(System cache support)**  
AXI协议的缓存支持信号使主设备能够为系统级缓存提供事务的可缓冲、可缓存和可分配属性。  
请参见第5-2页的缓存支持。

**保护单元支持(Protection unit support)**  
为了支持特权和安全访问，AXI协议提供了三级保护单元支持。  
请参见第5-5页的保护单元支持。

**原子操作(Atomic operations)**  
AXI协议定义了独占和锁定访问的机制。  
请参见第6章原子访问。

**错误支持(Error support)**  
AXI协议为地址解码错误和从设备生成的错误提供了错误支持。  
请参见第7章响应信号。

**非对齐地址(Unaligned address)**  
为了提高突发内初始访问的性能，AXI协议支持非对齐的突发开始地址。  
请参见第10章非对齐传输。


# 第二章 信号描述(Signal Descriptions)



本章定义了AXI信号。虽然总线宽度和事务ID宽度是特定于实现的，但本章的表格显示了一个32位数据总线，一个四位写数据选通，和四位ID字段。本章包含以下部分：

-   全局信号，见第2-2页
-   写地址通道信号，见第2-3页
-   写数据通道信号，见第2-4页
-   写响应通道信号，见第2-5页
-   读地址通道信号，见第2-6页
-   读数据通道信号，见第2-7页
-   低功耗接口信号，见第2-8页

## 2.1全局信号

| 信号 | 来源 | 描述 |
| --- | --- | --- |
| ACLK | 时钟源 | 全局时钟信号。所有信号都在全局时钟的上升沿被采样。 |
| ARESETn | 重置源 | 全局重置信号。此信号为低电平有效。 |

## 2.2写地址通道信号

| 信号 | 来源 | 描述 |
| --- | --- | --- |
| AWID[3:0] | 主设备 | 写地址ID。此信号是写地址组信号的标识符。 |
| AWADDR[31:0] | 主设备 | 写地址。写地址总线给出了写突发事务中第一次传输的地址。相关的控制信号用于确定突发中其余传输的地址。 |
| AWLEN[3:0] | 主设备 | 突发长度。突发长度给出了突发中的确切传输次数。此信息确定了与地址相关的数据传输次数。参见第4-3页的表4-1。 |
| AWSIZE[2:0] | 主设备 | 突发大小。此信号指示突发中每次传输的大小。字节通道选通指示确切更新哪些字节通道。参见第4-4页的表4-2。 |
| AWBURST[1:0] | 主设备 | 突发类型。突发类型，结合大小信息，详细说明了如何计算突发中每次传输的地址。参见第4-5页的表4-3。 |
| AWLOCK[1:0] | 主设备 |锁定类型。此信号提供了关于传输原子特性的额外信息。参见第6-2页的表6-1。|
| AWCACHE[3:0] | 主设备 |缓存类型。此信号指示事务的可缓冲，可缓存，写入，写回和分配属性bufferable, cacheable, write-through, write-back,allocate attributes。参见第5-3页的表5-1。|
| AWPROT[2:0] | 主设备 |保护类型。此信号指示事务的正常，特权或安全保护级别以及事务是数据访问还是指令访问。参见第5-5页的保护单元支持。|
| AWVALID | 主设备 | 写地址有效。此信号指示有效的写地址和控制信息是否可用：1 = 地址和控制信息可用 0 = 地址和控制信息不可用。地址和控制信息保持稳定，直到地址确认信号，AWREADY，变为高电平。 |
| AWREADY | 从设备 | 写地址准备好。此信号指示从设备是否准备好接受地址和相关的控制信号：1 = 从设备准备好 0 = 从设备未准备好。 |

## 2.3 写数据通道信号

| 信号 | 来源 | 描述 |
| --- | --- | --- |
| WID[3:0] | 主设备 | 写ID标签。此信号是写数据传输的ID标签。WID值必须与写事务的AWID值匹配。 |
| WDATA[31:0] | 主设备 | 写数据。写数据总线可以是8，16，32，64，128，256，512或1024位宽。 |
| WSTRB[3:0] | 主设备 | 写选通。此信号指示在内存中更新哪些字节通道。每8位的写数据总线有一个写选通。因此，WSTRB[n]对应于WDATA[(8°n)+7:(8°n)]。 |
| WLAST | 主设备 | 写最后。此信号指示写突发中的最后一次传输。 |
| WVALID | 主设备 | 写有效。此信号指示有效的写数据和选通是否可用：1 = 写数据和选通可用 0 = 写数据和选通不可用。 |
| WREADY | 从设备 | 写准备好。此信号指示从设备是否可以接受写数据：1 = 从设备准备好 0 = 从设备未准备好。 |


## 2.4 写响应通道信号

| 信号 | 来源 | 描述 |
| --- | --- | --- |
| BID[3:0] | 从设备 | 响应ID。写响应的标识符。BID值必须与从设备正在响应的写事务的AWID值匹配。 |
| BRESP[1:0] | 从设备 | 写响应。此信号指示写事务的状态。允许的响应是OKAY，EXOKAY，SLVERR和DECERR。 |
| BVALID | 从设备 | 写响应有效。此信号指示有效的写响应是否可用：1 = 写响应可用 0 = 写响应不可用。 |
| BREADY | 主设备 | 响应准备好。此信号指示主设备是否可以接受响应信息。1 = 主设备准备好 0 = 主设备未准备好。 |


## 2.5读地址通道信号

| 信号 | 来源 | 描述 |
| --- | --- | --- |
| ARID[3:0] | 主设备 | 读地址ID。此信号是读地址组信号的标识符。 |
| ARADDR[31:0] | 主设备 | 读地址。读地址总线提供读突发事务的初始地址。只提供突发的起始地址，伴随地址发出的控制信号详细说明了突发中剩余传输的地址如何计算。 |
| ARLEN[3:0] | 主设备 | 突发长度。突发长度给出突发中的准确传输次数。此信息确定与地址相关的数据传输次数。参见第4-3页的表4-1。 |
| ARSIZE[2:0] | 主设备 | 突发大小。此信号指示突发中每次传输的大小。参见第4-4页的表4-2。 |
| ARBURST[1:0] | 主设备 | 突发类型。突发类型，结合大小信息，详细说明了突发中每次传输的地址如何计算。参见第4-5页的表4-3。 |
| ARLOCK[1:0] | 主设备 | 锁定类型。此信号提供有关传输的原子特性的附加信息。参见第6-2页的表6-1。 |
| ARCACHE[3:0] | 主设备 | 缓存类型。此信号提供有关传输的可缓存特性的附加信息。参见第5-3页的表5-1。 |
| ARPROT[2:0] | 主设备 | 保护类型。此信号为事务提供保护单元信息。参见第5-5页的保护单元支持。 |
| ARVALID | 主设备 | 读地址有效。此信号在高电平时指示读地址和控制信息有效，并将保持稳定，直到地址确认信号ARREADY为高电平。1 = 地址和控制信息有效 0 = 地址和控制信息无效。 |
| ARREADY | 从设备 | 读地址准备好。此信号指示从设备已准备好接受地址和相关控制信号：1 = 从设备准备好 0 = 从设备未准备好。 |


## 2.6读数据通道信号

| 信号 | 来源 | 描述 |
| --- | --- | --- |
| RID[3:0] | 从设备 | 读ID标签。此信号是读数据组信号的ID标签。RID值由从设备生成，并且必须与其正在响应的读事务的ARID值匹配。 |
| RDATA[31:0] | 从设备 | 读数据。读数据总线可以是8，16，32，64，128，256，512或1024位宽。 |
| RRESP[1:0] | 从设备 | 读响应。此信号指示读传输的状态。允许的响应是OKAY，EXOKAY，SLVERR和DECERR。 |
| RLAST | 从设备 | 读最后。此信号指示读突发中的最后一次传输。 |
| RVALID | 从设备 | 读有效。此信号指示所需的读数据是否可用以及读传输是否可以完成：1 = 读数据可用 0 = 读数据不可用。 |
| RREADY | 主设备 | 读准备好。此信号指示主设备是否可以接受读数据和响应信息：1 = 主设备准备好 0 = 主设备未准备好。 |


## 2.7低功耗接口信号

| 信号 | 来源 | 描述 |
| --- | --- | --- |
| CSYSREQ | 时钟控制器 | 系统低功耗请求。此信号是系统时钟控制器请求外设进入低功耗状态的请求。 |
| CSYSACK | 外设设备 | 低功耗请求确认。此信号是外设对系统低功耗请求的确认。 |
| CACTIVE | 外设设备 | 时钟活动。此信号指示外设需要其时钟信号：1 = 需要外设时钟 0 = 不需要外设时钟。 |


# 第三章 通道握手(Channel Handshake)



本章描述了主/从握手过程，并概述了READY和VALID握手信号的关系和默认值。它包含以下部分：

-   握手过程，见第3-2页
-   通道之间的关系，见第3-6页
-   通道握手信号之间的依赖关系，见第3-7页



## 3.1 握手过程(Handshake process)

所有五个通道都使用相同的VALID / READY握手来传输数据和控制信息。这种双向流控制机制使主设备和从设备都能控制数据和控制信息的传输速率。源设备生成`VALID`信号，以指示何时有数据或控制信息可用。目标设备生成`READY`信号，以指示它接受数据或控制信息。只有当`VALID`和`READY`信号都为高电平时，才会发生传输。

在主设备和从设备接口的输入和输出信号之间，不得存在组合路径。

第3-3页的图3-1至图3-3显示了握手序列的示例。在图3-1中，源设备提供数据或控制信息，并将`VALID`信号拉高。源设备的数据或控制信息保持稳定，直到目标设备将`READY`信号拉高，表明它接受数据或控制信息。箭头显示了传输发生的时刻。

![[学习/verilog学习/AMBA/AXI/图片/3-1.jpg]]


在第3-3页的图3-2中，目标设备在数据或控制信息有效之前就将`READY`信号拉高。这表明，目标设备可以在数据或控制信息一旦有效时，立即在一个周期内接受数据或控制信息。箭头显示了传输发生的时刻。


![[学习/verilog学习/AMBA/AXI/图片/3-2.jpg]]


在图3-3中，源设备和目标设备恰好在同一周期内指示它们可以传输数据或控制信息。在这种情况下，传输立即发生。箭头显示了传输发生的时刻。


![[3-3.jpg]]


以下是各个AXI协议通道握手机制的描述：

-   写地址通道
-   第3-4页的写数据通道
-   第3-4页的写响应通道
-   第3-4页的读地址通道
-   第3-5页的读数据通道。

### 3.1.1 写地址通道

主设备只有在驱动有效的地址和控制信息时，才能激活`AWVALID`信号。它必须保持激活状态，直到从设备接受地址和控制信息，并激活相关的`AWREADY`信号。

`AWREADY`的默认值可以是高电平或低电平。推荐的默认值是高电平，尽管如果`AWREADY`是高电平，那么从设备必须能够接受呈现给它的任何有效地址。

`AWREADY`的默认值也可以是低电平，但不推荐，因为这意味着传输至少需要两个周期，一个周期用于激活`AWVALID`，另一个周期用于激活`AWREADY`。

### 3.1.2 写数据通道

在写突发过程中，主设备只有在驱动有效的写数据时，才能激活`WVALID`信号。`WVALID`必须保持激活状态，直到从设备接受写数据，并激活`WREADY`信号。

`WREADY`的默认值可以是高电平，但只有在从设备总是能在一个周期内接受写数据的情况下才可以。

主设备必须在驱动突发中的最后一个写传输时，激活`WLAST`信号。

当`WVALID`为低电平时，`WSTRB[3:0]`信号可以取任何值，尽管推荐将它们驱动为低电平或保持在它们之前的值。

### 3.1.3 写响应通道

从设备只有在驱动有效的写响应时，才能激活`BVALID`信号。`BVALID`必须保持激活状态，直到主设备接受写响应，并激活`BREADY`信号。

`BREADY`的默认值可以是高电平，但只有在主设备总是能在一个周期内接受写响应的情况下才可以。

### 3.1.4 读地址通道

主设备只有在驱动有效的地址和控制信息时，才能激活`ARVALID`信号。它必须保持激活状态，直到从设备接受地址和控制信息，并激活相关的`ARREADY`信号。

`ARREADY`的默认值可以是高电平或低电平。推荐的默认值是高电平，尽管如果`ARREADY`是高电平，那么从设备必须能够接受呈现给它的任何有效地址。

`ARREADY`的默认值也可以是低电平，但不推荐，因为这意味着传输至少需要两个周期，一个周期用于激活`ARVALID`，另一个周期用于激活`ARREADY`。

### 3.1.5 读数据通道

从设备只有在驱动有效的读数据时，才能激活`RVALID`信号。`RVALID`必须保持激活状态，直到主设备接受数据，并激活`RREADY`信号。即使从设备只有一个读数据源，它也只能在对数据的请求响应中激活`RVALID`信号。

主设备接口使用`RREADY`信号来表示它接受数据。`RREADY`的默认值可以是高电平，但只有在主设备能够立即接受读数据，无论何时进行读取事务时，才可以。

从设备必须在驱动突发中的最后一个读取传输时，激活`RLAST`信号。

## 3.2 通道之间的关系

地址、读、写和写响应通道之间的关系是灵活的。例如，写数据可以在与其相关的写地址之前出现在接口上。这可能发生在写地址通道包含比写数据通道更多的寄存器阶段的情况下。也可能在同一周期内出现地址和写数据。

当互连必须确定目的地址空间或从设备空间时，它必须重新对齐地址和写数据。这是必需的，以确保只向其目的地的从设备信号写数据为有效。

必须维护的两个关系是：

-   读数据必须始终跟随与数据相关的地址
-   写响应必须始终跟随与写响应相关的写事务中的最后一个写传输。

## 3.3 通道握手信号之间的依赖关系

为了防止死锁情况，必须注意握手信号之间存在的依赖关系。

在任何交易中：

-   一个AXI组件的`VALID`信号不能依赖于交易中另一个组件的`READY`信号
-   `READY`信号可以等待`VALID`信号的激活。

注意：  
虽然在激活`READY`之前等待`VALID`被激活是可以接受的，但在`VALID`激活之前默认激活`READY`也是可以接受的，这可能导致设计更为高效。

图3-4和图3-5在第3-8页显示了握手信号的依赖关系。单向箭头指向可以在前一个信号激活之前或之后激活的信号。双向箭头指向只能在前一个信号激活后才能激活的信号。

图3-4显示，在读取交易中：

-   从设备可以等待`ARVALID`被激活，然后激活`ARREADY`
-   从设备必须等待`ARVALID`和`ARREADY`都被激活，然后开始通过激活`RVALID`返回读取数据。


![[3-4.jpg]]


图3-5在第3-8页显示，在写入交易中：

-   主设备在激活`AWVALID`或`WVALID`之前，不能等待从设备激活`AWREADY`或`WREADY`。
-   从设备可以在激活`AWREADY`之前，等待`AWVALID`或`WVALID`，或两者都等待。
-   从设备可以在激活`WREADY`之前，等待`AWVALID`或`WVALID`，或两者都等待。
-   从设备必须等待`WVALID`和`WREADY`都被激活，然后激活`BVALID`。


![[3-5.jpg]]


注意：  
在写入交易中，主设备在驱动`WVALID`之前，必须不等待`AWREADY`被激活。这是非常重要的，因为如果从设备相反地在激活`AWREADY`之前等待`WVALID`，那么可能会导致死锁条件。


# 第4章 地址选项

本章描述了AXI突发类型以及如何计算突发内传输的地址和字节通道。它包含以下几个部分：

-   第4-2页关于地址选项
-   第4-3页突发长度
-   第4-4页突发大小
-   第4-5页突发类型
-   第4-7页突发地址。

### 4.1 关于地址选项

AXI协议是基于突发的，主设备通过驱动传输控制信息和传输中第一个字节的地址开始每个突发。随着突发交易的进行，计算突发中后续传输的地址是从设备的责任。

为了防止突发跨越从设备之间的边界，并限制从设备内部所需要的地址递增器的大小，突发不得跨越**4KB**的边界。

### 4.2 突发长度

`AWLEN`或`ARLEN`信号指定了每个突发内发生的数据传输的数量。如表4-1所示，每个突发可以长1-16个传输。

| ARLEN/AWLEN[3:0] | Number of data transfers |
|------------------|--------------------------|
| b0000            | 1                        |
| b0001            | 2                        |
| b0010            | 3                        |
| ...              | ...                      |
| b1101            | 14                       |
| b1110            | 15                       |
| b1111            | 16                       |


对于环绕突发，突发的长度必须为2，4，8或16个传输。

每个交易必须有由`ARLEN`或`AWLEN`指定的传输数量。没有组件可以提前终止突发以减少数据传输的数量。**在写突发期间，主设备可以通过取消激活所有写入选通，但它必须完成突发中剩余的传输。在读突发期间，主设备可以丢弃进一步的读取数据，但它必须完成突发中剩余的传输。**

警告：  
丢弃不需要的读取数据可能会在访问如FIFO这样的读敏感设备时导致数据丢失。主设备绝不能使用比所需更长的突发长度访问这样的设备。


## 4.2 Burst 大小
表4-2展示了`ARSIZE`或`AWSIZE`信号如何指定每个突发内每次节拍或数据传输中要传输的最大数据字节数。
| ARSIZE/AWSIZE[2:0] | Bytes in transfer |
|--------------------|-------------------|
| b000               | 1                 |
| b001               | 2                 |
| b010               | 4                 |
| b011               | 8                 |
| b100               | 16                |
| b101               | 32                |
| b110               | 64                |
| b111               | 128               |

AXI通过传输地址确定每次传输要使用的数据总线的哪些字节通道。

对于传输大小小于数据总线的**递增或环绕突发**，每个突发的每个节拍的数据传输都在不同的字节通道上。固定突发的地址保持不变，每次传输都使用相同的字节通道。

任何传输的大小都不能超过交易中组件的数据总线宽度。

## 4.4 突发类型

AXI协议定义了以下三种突发类型：

-   固定突发
-   递增突发
-   环绕突发（参见第4-6页）

表4-3展示了`ARBURST`或`AWBURST`信号如何选择突发类型。

| ARBURST/AWBURST[1:0] | 突发类型 (Burst type) | 描述 | 访问方式 (Access) |
|----------------------|-----------------------|------|-------------------|
| b00                  |固定 (FIXED)| 固定地址突发 | FIFO类型 (FIFO-type) |
| b01                  |递增 (INCR)| 递增地址突发 | 正常顺序内存 (Normal sequential memory) |
| b10                  |环绕 (WRAP)| 递增地址突发，到达包裹边界时回到较低地址 | 缓存行 (Cache line) |
| b11                  | 保留 (Reserved)       | - | - |

### 4.4.1 固定突发(FIXED)

在固定突发中，突发中每次传输的地址都保持不变。这种突发类型适用于对相同位置的重复访问，比如加载或清空外设FIFO。

### 4.4.2 递增突发(INCR)

在递增突发中，突发中每次传输的地址是上一次传输地址的增量。增量值取决于传输的大小。例如，一个四字节大小的突发中每次传输的地址是上一次的地址加四。

### 4.4.3 环绕突发(WRAP)

环绕突发与递增突发类似，突发中每次传输的地址是上一次传输地址的增量。然而，在环绕突发中，当达到环绕边界时，地址会回环到较低的地址。环绕边界是突发中每次传输的大小乘以突发中的总传输次数。

环绕突发有两个限制：

-   起始地址必须与传输的大小对齐
-   突发的长度必须为2、4、8或16。


## 4.5 突发地址
这一部分提供了一些简单的公式，用于确定突发内传输的地址和字节通道。这些公式使用以下变量：
| 值 | 描述 |
|----|------|
| Start_Address | 主设备发出的起始地址 |
| Number_Bytes | 每次数据传输中的最大字节数 |
| Data_Bus_Bytes | 数据总线中的字节通道数 |
| Aligned_Address | 起始地址的对齐版本 |
| Burst_Length | 一次突发中的总数据传输次数 |
| Address_N | 突发中传输N的地址，N是2-16的整数 |
| Wrap_Boundary | 包裹突发中的最低地址 |
| Lower_Byte_Lane | 传输的最低地址字节的字节通道 |
| Upper_Byte_Lane | 传输的最高地址字节的字节通道 |
| INT(x) | x的向下取整的整数值 |
以下是确定突发内传输地址的公式：

-   `Start_Address = ADDR`
-   `Number_Bytes = 2的SIZE次方`
-   `Burst_Length = LEN + 1`
-   `Aligned_Address = (INT(Start_Address / Number_Bytes)) x Number_Bytes`

使用以下公式确定突发中第一次传输的地址：

-   `Address_1 = Start_Address`

使用以下公式确定突发中第一次传输之后任何传输的地址：

-   `Address_N = Aligned_Address + (N - 1) x Number_Bytes`

对于环绕突发，`Wrap_Boundary`变量扩展以考虑环绕边界：

-   `Wrap_Boundary = (INT(Start_Address / (Number_Bytes x Burst_Length))) x (Number_Bytes x Burst_Length)`

如果`Address_N = Wrap_Boundary + (Number_Bytes x Burst_Length)`，使用以下公式：

-   `Address_N = Wrap_Boundary`(循环回来)

使用以下公式确定突发中第一次传输应使用哪些字节通道：

-   `Lower_Byte_Lane = Start_Address - (INT(Start_Address / Data_Bus_Bytes)) x Data_Bus_Bytes`
-   `Upper_Byte_Lane = Aligned_Address + (Number_Bytes - 1) - (INT(Start_Address / Data_Bus_Bytes)) x Data_Bus_Bytes`

使用以下公式确定突发中第一次传输之后所有传输应使用哪些字节通道：

-   `Lower_Byte_Lane = Address_N - (INT(Address_N / Data_Bus_Bytes)) x Data_Bus_Bytes`
-   `Upper_Byte_Lane = Lower_Byte_Lane + Number_Bytes - 1`

数据在以下位置传输：

-   `DATA[(8 x Upper_Byte_Lane) + 7 : (8 x Lower_Byte_Lane)]`


以下是对这些公式中使用的变量的详细解释：

-   `Start_Address`：由主设备发出的起始地址。
-   `Number_Bytes`：每次数据传输中的最大字节数。
-   `Data_Bus_Bytes`：数据总线中的字节通道数量。
-   `Aligned_Address`：起始地址的对齐版本。这是通过将起始地址除以每次传输的最大字节数（取整后）再乘以该最大字节数得到的，确保了地址在字节边界上对齐。
-   `Burst_Length`：突发内的总数据传输次数。这是通过将AXI协议中的`LEN`字段值加1得到的，因为`LEN`字段的值范围是0-15，表示的是除第一次传输外的剩余传输次数。
-   `Address_N`：突发中第N次传输的地址。N是2-16的整数。这是通过将起始地址对齐后的地址与`(N-1)`倍的每次传输的最大字节数相加得到的。
-   `Wrap_Boundary`：环绕突发中的最低地址。这是通过将起始地址除以（每次传输的最大字节数与突发长度的乘积）（取整后）再乘以该乘积得到的，表示了地址在突发传输中的回环点。
-   `Lower_Byte_Lane`：传输中最低地址字节的字节通道。这是通过将传输地址除以数据总线的字节数（取整后）再乘以该字节数后从传输地址中减去得到的，表示了数据在数据总线中的起始位置。
-   `Upper_Byte_Lane`：传输中最高地址字节的字节通道。这是通过将`Lower_Byte_Lane`与每次传输的最大字节数减1的结果相加得到的，表示了数据在数据总线中的结束位置。
-   `INT(x)`：x的向下取整的整数值。这用于确保地址对齐和计算字节通道时的整数运算。

这些公式和变量的使用，使得在AXI协议中进行突发传输时，可以准确地计算出每次传输的地址和需要使用的数据总线的字节通道。

### 第五章 额外的控制信息

本章描述了AXI协议对系统级缓存和保护单元的支持。它包含以下部分：

-   第5-2页的缓存支持
-   第5-5页的保护单元支持。

### 5.1 缓存支持

系统级缓存和其他性能增强组件的支持是通过使用缓存信息信号 `ARCACHE` 和 `AWCACHE` 提供的。这些信号提供了关于如何处理事务的额外信息。

`ARCACHE[3:0]` 或 `AWCACHE[3:0]` 信号通过提供事务的可缓冲、可缓存和可分配属性，支持系统级缓存：

-   可缓冲（B）位，`ARCACHE[0]` 和 `AWCACHE[0]`  
    当此位为高时，意味着互连或任何组件可以将事务达到最终目的地的时间延迟任意数量的周期。这通常只与写操作相关。
    
-   可缓存（C）位，`ARCACHE[1]` 和 `AWCACHE[1]`  
    当此位为高时，意味着最终目的地的事务不必匹配原始事务的特性。  
    对于写操作，这意味着可以将许多不同的写操作合并在一起。  
    对于读操作，这意味着可以预取一个位置，或者只为多个读取事务获取一次。  
    要确定是否应缓存事务，应该结合使用读取分配（RA）和写入分配（WA）位。
    
-   读取分配（RA）位，`ARCACHE[2]` 和 `AWCACHE[2]`  
    当 RA 位为高时，意味着如果传输是读取并且在缓存中未命中，则应分配它。  
    如果 C 位为低，RA 位不得为高。
    
-   写入分配（WA）位，`ARCACHE[3]` 和 `AWCACHE[3]`  
    当 WA 位为高时，意味着如果传输是写入并且在缓存中未命中，则应分配它。  
    如果 C 位为低，WA 位不得为高。


 `ARCACHE[3:0]/AWCACHE[3:0]` 
|WA|RA | C |B| 事务属性 |
|----|----|---|---|----------|
| 0  | 0  | 0 | 0 | 非缓存且非缓冲 |
| 0  | 0  | 0 | 1 | 仅缓冲 |
| 0  | 0  | 1 | 0 | 可缓存，但不分配 |
| 0  | 0  | 1 | 1 | 可缓存且可缓冲，但不分配 |
| 0  | 1  | 0 | 0 | 保留 |
| 0  | 1  | 0 | 1 | 保留 |
| 0  | 1  | 1 | 0 | 可缓存写入，仅在读取时分配 |
| 0  | 1  | 1 | 1 | 可缓存写回，仅在读取时分配 |
| 1  | 0  | 0 | 0 | 保留 |
| 1  | 0  | 0 | 1 | 保留 |
| 1  | 0  | 1 | 0 | 可缓存写入，仅在写入时分配 |
| 1  | 0  | 1 | 1 | 可缓存写回，仅在写入时分配 |
| 1  | 1  | 0 | 0 | 保留 |
| 1  | 1  | 0 | 1 | 保留 |
| 1  | 1  | 1 | 0 | 可缓存写入，读取和写入时都分配 |
| 1  | 1  | 1 | 1 | 可缓存写回，读取和写入时都分配 |

在写事务的情况下，`AWCACHE` 信号可以用来确定哪个组件提供写响应。如果一个写事务被标记为可缓冲的，那么桥接器或系统级缓存提供写响应是可以接受的。然而，如果事务被标记为不可缓冲的，那么写响应必须由事务的最终目的地提供。

AXI协议并没有规定缓冲或缓存数据到达其目的地的机制。例如，系统级缓存可能有一个控制器来管理清理、刷新和使缓存条目无效。另一个例子是包含写缓冲区的桥接器，如果它接收到一个与事务ID匹配的不可缓冲的写操作，它可能有控制逻辑来清空缓冲区。

在 AXI 协议中，`ARCACHE` 和 `AWCACHE` 信号用于描述事务的缓存属性。以下是对这些属性的解释：

-   **可缓冲（Bufferable）**：如果一个事务被标记为可缓冲，那么互连或其他组件可以在事务到达其最终目的地的时间上增加任意数量的延迟。这通常与写操作有关，因为写操作可以被暂存（或缓冲）在某个地方（例如，一个写缓冲区），然后在稍后的时间点完成，而不是立即写入其最终目的地。这可以提高系统的性能，因为它允许系统在等待写入完成时进行其他操作。
    
-   **可缓存（Cacheable）**：如果一个事务被标记为可缓存，那么最终目的地的事务不必匹配原始事务的特性。对于写操作，这意味着可以将许多不同的写操作合并在一起。对于读操作，这意味着可以预取一个位置，或者只为多个读取事务获取一次。这可以提高系统的性能，因为它减少了系统必须执行的读取和写入操作的数量。
    
-   **分配（Allocate）**：分配属性实际上分为两部分：读取分配（Read Allocate）和写入分配（Write Allocate）。当读取分配位为高时，如果传输是读取并且在缓存中未命中，则应分配它。当写入分配位为高时，如果传输是写入并且在缓存中未命中，则应分配它。"分配"在这里的意思是，如果一个读或写操作在缓存中未命中，那么系统应该在缓存中为该操作创建一个新的条目。这可以提高系统的性能，因为它减少了系统必须从主存储器中获取数据的次数。

## 5.2 保护单元支持

为了支持复杂的系统设计，互连和系统中的其他设备通常需要提供对非法事务的保护。`AWPROT` 或 `ARPROT` 信号提供了三级访问保护：

-   正常或特权，`ARPROT[0]` 和 `AWPROT[0]`
    
    -   低电平表示正常访问
    -   高电平表示特权访问。  
        这被一些主设备用来表示它们的处理模式。特权处理模式通常在系统内部有更高级别的访问权限。
-   安全或非安全，`ARPROT[1]` 和 `AWPROT[1]`
    
    -   低电平表示安全访问
    -   高电平表示非安全访问。  
        这在需要更大程度区分处理模式的系统中使用。  
        注意：当此位为高时，事务被视为非安全，当为低时，事务被视为安全。
-   指令或数据，`ARPROT[2]` 和 `AWPROT[2]`
    
    -   低电平表示数据访问
    -   高电平表示指令访问。  
        这一位给出了事务是指令还是数据访问的指示。  
        注意：这种指示作为提示提供，并不在所有情况下都准确。例如，一个事务包含指令和数据项的混合。建议默认情况下，访问被标记为数据访问，除非明确知道它是指令访问。

表5-2总结了 `ARPROT[2:0]` 和 `AWPROT[2:0]` 信号的编码。


| ARPROT[2:0]/AWPROT[2:0] | 保护级别 |
|-------------------------|----------|
| [0]                     | 1 = 特权访问<br>0 = 普通访问 |
| [1]                     | 1 = 非安全访问<br>0 = 安全访问 |
| [2]                     | 1 = 指令访问<br>0 = 数据访问 |




# 第六章 原子访问

本章描述了AXI协议如何实现独占访问和锁定访问机制。它包含以下几部分：

-   第6-2页关于原子访问
-   第6-3页独占访问
-   第6-7页锁定访问。

## 6.1 关于原子访问

为了实现原子访问原语，`ARLOCK[1:0]` 或 `AWLOCK[1:0]` 信号提供了独占访问和锁定访问。表6-1显示了 `ARLOCK[1:0]` 和 `AWLOCK[1:0]` 信号的编码。

| ARLOCK[1:0]/AWLOCK[1:0] | 访问类型 |
|-------------------------|----------|
| b00                     | 正常访问 |
| b01                     | 独占访问 |
| b10                     | 锁定访问 |
| b11                     | 保留 |


## 6.2 独占访问

独占访问机制使得可以实现信号量类型的操作，而无需在操作期间将总线锁定到特定的主设备。独占访问的优点是，信号量类型的操作既不影响关键的总线访问延迟，也不影响最大可达的带宽。

`ARLOCK[1:0]` 或 `AWLOCK[1:0]` 信号选择独占访问，而 `RRESP[1:0]` 或 `BRESP[1:0]` 信号（参见第7-2页的表7-1）指示独占访问的成功或失败。

**从设备必须有额外的逻辑来支持独占访问**。AXI协议提供了一个故障安全机制，用来指示当主设备试图对不支持它的从设备进行独占访问时。

### 6.2.1 独占访问过程

独占访问的基本过程是：

1.  主设备从一个地址位置执行独占读取。
2.  在稍后的某个时间，主设备试图通过对同一地址位置执行独占写入来完成独占操作。
3.  主设备的独占写访问被标记为：
    -   如果在读取和写入访问之间，没有其他主设备写入该位置，则标记为成功。
    -   如果在读取和写入访问之间，另一个主设备写入了该位置，则标记为失败。在这种情况下，地址位置不会被更新。

注意：主设备可能不会完成独占操作的写部分。独占访问监控硬件必须**每个事务ID只监控一个地址**。因此，如果主设备没有完成独占操作的写部分，那么后续的独占读取会改变正在被监控的地址。

### 6.2.2 从主设备的角度看独占访问

主设备通过执行独占读取来启动独占操作。这通常会从从设备返回`EXOKAY`响应，表示从设备记录了需要监控的地址。

注意：如果主设备试图从不支持独占访问的从设备那里进行独占读取，那么从设备会返回`OKAY`响应，而不是`EXOKAY`响应。主设备可以将此视为错误条件，表示不支持独占访问。建议主设备不要执行这个独占操作的写部分。

在独占读取之后的某个时间，主设备尝试对同一位置进行独占写入。如果该位置自独占读取以来未发生变化，独占写入操作就会成功。从设备返回`EXOKAY`响应，独占写入更新内存位置。

如果自独占读取以来地址位置已经改变，独占写入尝试失败，从设备返回OKAY响应，而不是`EXOKAY`响应。独占写入尝试不会更新内存位置。

主设备可能不会完成独占操作的写部分。如果发生这种情况，从设备会继续监控地址的独占性，直到另一个独占读取启动新的独占访问。

主设备在读部分完成之前，不得开始独占访问的写部分。

### 6.2.3 从从设备的角度看独占访问

不支持独占访问的从设备可以忽略 `ARLOCK[1:0]` 和 `AWLOCK[1:0]` 信号。它必须为正常访问和独占访问提供OKAY响应。

支持独占访问的从设备必须有监控硬件。建议这样的从设备对每个能够访问它的具有独占能力的主设备ID都有一个监控单元。单端口的从设备可以在从设备外部有一个标准的独占访问监控器，但是多端口的从设备可能需要内部监控。

独占访问监控器记录任何独占读操作的地址和`ARID`值。然后它监控该位置，直到该位置发生写入或者另一个具有相同`ARID`值的独占读将监控器重置为不同的地址。

当发生具有给定`AWID`值的独占写入时，监控器会检查该地址是否正在被监控以保证独占性。如果是，那么这意味着该位置没有发生写入，独占写入继续进行，完成独占访问。从设备向主设备返回`EXOKAY`响应。

如果在独占写入时该地址不再被监控，这意味着以下情况之一：

-   自独占读取以来，位置已被更新
-   监控器已被重置为另一个位置。

在这两种情况下，独占写入都不应更新地址位置，从设备必须返回OKAY响应，而不是`EXOKAY`响应。

### 6.2.4 独占访问的限制

以下限制适用于独占访问：

-   具有给定ID的独占写入的大小和长度必须与具有相同ID的前面的独占读取的大小和长度相同。
-   独占访问的地址必须与交易中的总字节数对齐。
-   独占读取和独占写入的地址必须相同。
-   独占访问的读部分的`ARID`字段必须与写部分的`AWID`匹配。
-   独占访问的读和写部分的控制信号必须相同。
-   在独占访问突发中要传输的字节数必须是2的幂，即1、2、4、8、16、32、64或128字节。
-   在独占突发中可以传输的最大字节数是128。
-   `ARCACHE[3:0]` 或 `AWCACHE[3:0]` 信号的值必须保证监控独占访问的从设备看到交易。例如，被从设备监控的独占访问不能有一个`ARCACHE[3:0]` 或 `AWCACHE[3:0]` 值，该值表明交易是可缓存的。

不遵守这些限制将导致不可预测的行为。

在独占操作期间要监控的最小字节数由交易的长度和大小定义。监控更大数量的字节是可以接受的，最多可以监控128字节，这是独占访问的最大值。然而，这可能导致独占访问实际上是成功的，但因为相邻的字节被更新，所以被指示为失败。

### 6.2.5 不支持独占访问的从设备

响应信号，`BRESP[1:0]` 和 `RRESP[1:0]`，包括对成功的正常访问的OKAY响应和对成功的独占访问的EXOKAY响应。这意味着不支持独占访问的从设备可以提供OKAY响应来表示独占访问的失败。

**注意**  
对不支持独占访问的从设备进行的独占写入总是更新内存位置。  
对支持独占访问的从设备进行的独占写入只有在独占写入成功时才更新内存位置。


## 6.3 锁定访问

当交易的 `ARLOCK[1:0]` 或 `AWLOCK[1:0]` 信号显示它是一个锁定传输时，互连必须确保**只允许那个主设备访问从设备区域**，直到来自同一主设备的解锁传输完成。互连中的仲裁器用于执行这个限制。

当主设备开始一个锁定的读或写交易序列时，它必须确保没有其他的未完成的交易在等待完成。

任何 `ARLOCK[1:0]` 或 `AWLOCK[1:0]` 设置为表示锁定序列的交易都会强制互连锁定以下的交易。因此，锁定序列必须始终以一个没有 `ARLOCK[1:0]` 或 `AWLOCK[1:0]` 设置为表示锁定访问的最终交易完成。这个最终交易包含在锁定序列中，并有效地移除了锁。

在完成一个锁定序列时，主设备必须确保所有以前的锁定交易在发出最终的解锁交易之前都已完成。然后它必须确保在开始任何进一步的交易之前，最终的解锁交易已完全完成。

主设备必须确保在一个锁定序列中的所有交易都有相同的 `ARID` 或 `AWID` 值。

**注意**  
锁定访问要求互连在锁定序列进行中阻止任何其他交易，因此可能会影响互连的性能。建议只在支持遗留设备时使用锁定访问。

以下限制是推荐的，但不是强制的：

-   保持所有锁定交易序列在同一4KB地址区域内
-   将锁定交易序列限制为两个交易。



# 第7章 响应信号  


本章描述了AXI读取和写入交易中的四种从设备响应。它包含以下部分：

-   关于响应信号，见第7-2页
-   响应类型，见第7-4页。


## 7.1 关于响应信号

AXI协议允许对读取和写入交易进行响应信号。对于读取交易，从设备的响应信息与读取的数据本身一同传递，但对于写入，响应信息是通过写入响应通道传递的。

AXI协议的响应有：

-   OKAY
-   EXOKAY
-   SLVERR
-   DECERR。

表7-1显示了 `RRESP[1:0]` 和 `BRESP[1:0]` 信号的编码。

| RRESP[1:0]/BRESP[1:0] | 响应 | 含义 |
|-----------------------|------|------|
| b00                   | OKAY |正常访问成功,表示正常访问已成功。也可以表示独占访问失败。|
| b01                   | EXOKAY |独占访问成功,表示独占访问的读取或写入部分已成功。|
| b10                   | SLVERR |从设备错误,用于访问已成功到达从设备，但从设备希望向发起主设备返回错误条件。|
| b11                   | DECERR |解码错误,通常由互连组件生成，以指示交易地址没有从设备。|


对于写入交易，**整个突发只给出一个响应**，而不是突发内的每个数据传输都有响应。

在读取交易中，**从设备可以为突发内的不同传输给出不同的响应**。例如，在16个读取传输的突发中，从设备可能对15个传输返回`OKAY`响应，对其中一个传输返回`SLVERR`响应。

协议规定，即使报告出现错误，也必须执行所需的数据传输数量。例如，如果从从设备请求读取8个传输，但从设备出现错误条件，那么从设备必须执行8个数据传输，每个传输都带有错误响应。如果从设备给出单个错误响应，突发的其余部分不会被取消。

该协议对可以发出多个未完成的地址并且也必须支持精确错误信号的主设备进行了限制。这样的主设备必须能够处理早期传输的错误响应，同时后续传输已经在进行中。

## 7.2 响应类型

本节描述了四种AXI协议的响应类型：

-   正常访问成功
-   独占访问
-   从设备错误
-   解码错误。

## 7.2.1 正常访问成功

`OKAY`响应表示：

-   正常访问的成功
-   独占访问的失败
-   对不支持独占访问的从设备进行独占访问。  
    OKAY是大多数交易的响应。

## 7.2.2 独占访问

`EXOKAY`响应表示独占访问的成功。第6章原子访问描述了这种响应。

## 7.2.3 从设备错误

`SLVERR`响应表示交易不成功。从设备错误条件的例子包括：

-   FIFO/缓冲区溢出或下溢条件
-   尝试不支持的传输大小
-   尝试对只读位置进行写访问
-   从设备中的超时条件
-   尝试访问没有寄存器的地址
-   尝试访问已禁用或已断电的功能。  
    为简化系统监控和调试，建议仅在错误条件下使用错误响应，而不用于信号正常，预期的事件。

## 7.2.4 解码错误

在没有完全解码的地址映射的系统中，可能存在没有从设备响应交易的地址。在这样的系统中，互连必须提供适当的错误响应来标记访问为非法，并防止系统试图访问不存在的从设备而锁定。

当互连无法成功解码从设备访问时，它将访问有效地路由到默认的从设备，而默认的从设备返回`DECERR`响应。

一个实现选项是让默认的从设备也记录解码错误的详细信息，以便后续确定错误是如何发生的。通过这种方式，默认的从设备可以显著简化调试过程。

AXI协议要求，即使发生错误条件，也必须完成交易的所有数据传输。因此，任何给出`DECERR`响应的组件都必须满足此要求。

# 第8章 排序模型


本章描述了AXI协议如何使用事务ID标签来支持发出多个未完成的地址和乱序事务处理。它包含以下部分：

-   关于排序模型（第8-2页）
-   传输ID字段（第8-3页）
-   读取排序（第8-4页）
-   正常写入排序（第8-5页）
-   写入数据交错（第8-6页）
-   读写交互（第8-8页）
-   互连使用ID字段（第8-9页）
-   推荐的ID字段宽度（第8-10页）。

## 8.1 关于排序模型

AXI协议支持乱序事务完成和发出多个未完成的地址。(out-of-order transaction completion and the issuing of multiple outstanding addresses)这些特性使得可以实现高性能的互连，最大化数据吞吐量和系统效率。

ID信号通过使每个端口能够作为多个有序端口来支持乱序事务。所有具有给定ID的事务必须是有序的，但对于具有不同ID的事务的排序没有限制。五个事务ID是：

-   AWID：写地址信号组的ID标签。
-   WID：写事务的写ID标签。主设备传输`WID`以匹配相应地址的`AWID`。
-   BID：写响应的ID标签。从设备传输BID以匹配它正在响应的事务的`AWID`和`WID`。
-   ARID：读地址信号组的ID标签。
-   RID：读事务的读ID标签。从设备传输`RID`以匹配它正在响应的事务的`ARID`。

注意:对于从设备和主设备来说，没有要求必须使用这些高级特性。简单的主设备和从设备可以按照它们发出的顺序一次处理一个事务。

能够发出多个未完成的地址意味着主设备可以在不等待早期事务完成的情况下发出事务地址。这个特性可以提高系统性能，因为它使得可以并行处理事务。

能够乱序完成事务意味着对于更快的内存区域的事务可以在不等待对较慢的内存区域的早期事务的情况下完成。这个特性也可以提高系统性能，因为它减少了事务延迟的影响。

注意:事务的重新排序总是相对于其他事务。没有在**突发内**对数据传输进行重新排序的功能。定义突发的地址和控制信号控制了突发内的传输顺序。


## 8.2 传输ID字段
AXI协议提供了一个ID字段，使得主设备可以发出一系列单独的事务，每个事务必须按顺序返回。

主设备可以使用事务的`ARID`或`AWID`字段提供关于主设备的排序要求的额外信息。控制事务排序的规则如下：
- 来自不同主设备的事务没有排序限制。他们可以按任意顺序完成。
- 来自同一主设备，但具有不同`ID`值的事务没有排序限制。他们可以按任意顺序完成。
- 具有相同`AWID`值的一系列写事务的数据必须按照主设备发出地址的顺序完成。
- 具有相同`ARID`值的一系列读事务的数据必须按照以下顺序返回：
  - 当具有相同`ARID`的读取来自同一从设备时，从设备必须确保读取的数据按照接收地址的顺序返回。
  - 当具有相同`ARID`的读取来自不同的从设备时，互连必须确保读取的数据按照主设备发出地址的顺序返回。
- 具有相同`AWID`和`ARID`的读写事务之间没有排序限制。如果主设备需要排序限制，那么它必须确保第一个事务在发出第二个事务之前完全完成。

## 8.3 读取排序
在主设备接口，具有相同`ARID`值的读取事务的读取数据必须按照主设备发出地址的顺序到达。具有不同`ARID`值的读取事务的数据可以按任意顺序返回，也可以交错返回具有不同`ARID`字段的事务的读取数据。

从设备必须按照接收地址的顺序返回具有相同`ARID`值的一系列读取事务的读取数据。在具有不同`ARID`值的一系列读取事务中，从设备可以按照与事务到达的顺序不同的顺序返回读取数据。

从设备必须确保任何返回的读取数据的`RID`值与它正在响应的地址的`ARID`值匹配。

互连必须确保来自不同从设备的具有相同`ARID`值的一系列读取事务按顺序完成。

读取数据**重新排序深度**(read data reordering depth)是从设备中可以重新排序的待处理地址的数量。按顺序处理所有事务的从设备的读取数据重新排序深度为一。读取数据重新排序深度是一个静态值，必须由从设备的设计者指定。

## 8.4 正常写入排序
如果一个从设备不支持写入数据交错（参见第8-6页的写入数据交错），主设备必须按照它发出事务地址的顺序发出写入事务的数据。

大多数从设备设计不支持写入数据交错，因此这些类型的从设备设计必须按照接收地址的顺序接收写入数据。如果互连将来自不同主设备的写入事务合并到一个从设备，它必须确保**按地址顺序**(combine ... in address order)合并写入数据。

即使写入事务具有不同的`AWID`值，这些限制也适用。

## 8.5 写入数据交错
写入数据交错使从设备接口能够接受具有不同`AWID`值的交错写入数据。从设备声明一个写入数据交错深度，该深度指示接口是否可以接受来自具有不同`AWID`值的源的交错写入数据。写入数据交错深度是静态配置的。默认情况下，任何接口的写入数据交错深度为一。

**注意**
不允许交错具有相同`AWID`的不同事务的写入数据。

写入数据交错深度(write data interleaving depth)是当前在从设备接口中挂起的不同地址的数量，可以为这些地址提供写入数据。例如，一个具有两个写入数据交错深度的从设备，有四个不同的地址，所有地址都具有不同的`AWID`值，挂起可以接受前两个挂起地址的数据。

从设备接收每个事务的第一个数据项的顺序必须与接收事务地址的顺序相同。

写入数据交错可以在互连合并多个流向同一从设备发送的写入数据时防止停滞。互连可能会合并来自慢速源的一个写入数据流和来自快速源的另一个写入数据流。通过交错两个写入数据流，互连可以提高系统性能。

**注意**
如果两个具有不同`AWID`值的写入事务访问相同或重叠的地址位置，那么处理顺序未定义。更高级别的协议必须确保事务处理的正确顺序。

能够生成只有一个`AWID`值的写入数据的主设备接口按照发出地址的顺序生成所有写入数据。然而，如果从设备接口的写入数据交错深度大于一，主设备接口可以交错具有不同`WID`值的写入数据。

对于大多数可以内部控制写入数据生成的主设备，不需要写入数据交错。这样的主设备可以按照生成地址的顺序生成写入数据。然而，一个正在从不同速度的多个源传递写入数据的主设备接口可以交错源以最大限度地利用互连。

为了避免死锁情况，只有在可以连续接受交错写入数据的情况下，从设备接口的写入交错深度才能大于一。从设备接口绝不能在试图改变写入数据的顺序时阻止接受写入数据。

## 8.6 读写交互
读写事务之间没有排序限制，它们可以按任意顺序完成。

如果主设备需要在读写事务之间建立特定的关系，则必须确保在发出后续事务之前完成先前的事务。在读取的情况下，当最后的读取数据返回给主设备时，可以认为先前的事务已完成。在写入的情况下，只有当写入响应被主设备接收时，事务才可以被认为已完成，仅当所有写入数据被发送时，就认为写入事务已完成是不可接受的。

对于由外设占据的地址区域，这通常意味着在切换需要排序限制的读写事务时，需要等待先前的事务完成。

对于内存区域，主设备可以对未完成的事务进行地址检查，以确定新事务是否可能是对相同或重叠的地址区域的事务。如果事务没有重叠，那么新事务可以在不等待先前事务完成的情况下开始。

## 8.7 互连对ID字段的使用
当主设备接口连接到互连时，互连会向`ARID`、`AWID`和`WID`字段追加唯一于该主端口的额外位。这有两个效果：

- 主设备不需要知道其他主设备使用的`ID`值，因为当互连将主设备号追加到字段时，会使`ID`值唯一。
- 在从设备接口处的`ID`字段宽度要比在主设备接口处的`ID`字段宽度宽。

对于读取数据，互连使用`RID`字段的额外位来确定读取数据的目标主端口。在将RID值传递给正确的主端口之前，互连会移除`RID`字段的这些位。

## 8.8 推荐的ID字段宽度
为了利用AXI的乱序事务处理能力，建议采用以下措施：

- 在主设备组件中实现最多四位的事务`ID`
- 在互连中为主端口号实现最多四位额外的事务`ID`
- 在从设备组件中实现八位的`ID`支持。

**注意：**

对于只支持单一有序接口的主设备，将`ID`输出绑定到常数值（如0）是可以接受的。

对于不使用排序信息并简单地按顺序处理所有事务的从设备，可以使用标准的现成模块为从设备添加`ID`功能，从而使得在没有`ID`信号的情况下设计从设备的基本功能成为可能。

# 第9章 数据总线

本章描述了在AXI读取和写入数据总线上的不同大小的传输，以及接口如何使用字节不变的字节序来处理混合字节序的传输。它包含以下几个部分：

-   数据总线简介（第9-2页）
-   写入选通（第9-3页）
-   窄传输（第9-4页Narrow transfers）
-   字节不变性（第9-5页Byte invariance）。


## 9.1 数据总线简介

AXI协议有两个独立的数据总线，一个用于读取数据，一个用于写入数据。由于这些数据总线各自有独立的握手信号，所以两个总线上的数据传输可以同时进行。

每个由主设备生成的传输的宽度必须与数据总线的宽度相同或更窄。

## 9.2 写入选通

写入选通信号`WSTRB`，使得在写数据总线上可以进行稀疏数据传输。每个写入选通信号对应写数据总线的一个字节。当选通信号被置位时，表示数据总线的相应字节通道包含有效的待更新到内存的信息。

每8位的写数据总线有一个写入选通，所以`WSTRB[n]`对应于`WDATA[(8*n) + 7: (8*n)]`。图9-1在64位数据总线上显示了这种关系。


![[9-1.jpg]]


主设备必须确保只有在字节通道可以包含有效数据时才置位写入选通，这是由事务的控制信息决定的。

## 9.3 窄传输
当主设备生成的传输宽度比其数据总线窄时，地址和控制信息决定了传输使用的字节通道。在递增或包装突发中，每个突发的每个节拍传输数据的字节通道都不同。在固定突发中，地址保持不变，可以使用的字节通道也保持不变。

图9-2和图9-3给出了两个字节通道使用的例子。

在图9-2中：
- 突发有五个传输
- 起始地址是0
- 每个传输是八位
- 传输在32位总线上进行。


![[9-2.jpg]]


在图9-3中：
- 突发有三个传输
- 起始地址是4
- 每个传输是32位
- 传输在64位总线上进行。

![[9-3.jpg]]



## 9.4 字节不变性
为了访问位于同一内存空间中的混合字节序数据结构，AXI协议使用了字节不变的字节序方案。

字节不变的字节序意味着对给定地址的字节传输将数据总线线路上的八位数据传输到同一地址位置。

只有一种传输宽度的组件必须将其字节通道连接到数据总线的适当字节通道。支持多种传输宽度的组件可能需要更复杂的接口来转换一个不自然的字节不变接口。

大多数小端字节序组件可以直接连接到字节不变的接口。只支持大端字节序传输的组件需要一个转换函数进行字节不变操作。

图9-4是一个需要字节不变访问的数据结构的例子。可能头信息，如源和目标标识符，是小端字节序格式，但载荷Payload是大端字节序字节流。

![[9-4.jpg]]

字节不变性确保对头信息部分的小端字节序访问不会破坏结构内的其他大端字节序数据。



# 第10章 非对齐传输

本章描述了AXI协议如何处理非对齐传输。它包含以下部分：

-   第10-2页关于非对齐传输
-   第10-3页的例子。


## 10.1 关于非对齐传输
AXI协议使用基于突发的寻址，这意味着每个事务由一系列数据传输组成。通常，每个数据传输都对齐到传输的大小。例如，一个32位宽的传输通常对齐到四字节边界。然而，有时候我们希望在一个非对齐的地址开始突发。

对于任何由比一个字节更宽的数据传输组成的突发传输，可能第一字节的访问并不对齐于自然数据宽度的边界。例如，一个从字节地址`0x1002`开始的32位（四字节）数据包并没有对齐到32位边界。

AXI协议允许主设备使用低位地址线路发出一个突发的非对齐起始地址信号。低位地址线路上的信息必须与字节通道选通信号上的信息一致。

注意，AXI协议并不要求从设备根据主设备的任何对齐信息采取特殊行动。

主设备也可以简单地提供一个对齐的地址，在写入事务中，依赖字节通道选通信号来提供数据使用的字节通道的信息。


## 10.2 示例
图10-1，图10-2（在第10-4页）和图10-3（在第10-4页）展示了在不同宽度的总线上对齐和非对齐传输的例子。图中的每一行代表一次传输。阴影单元格表示基于地址和控制信息没有被传输的字节。

![[10-1.jpg]]


图10-2展示了在64位总线上的三次32位传输的突发。

![[10-2.jpg]]


图10-3展示了在64位总线上的32位传输的环绕突发。

![[10-3.jpg]]



# 第11章 时钟和复位

本章描述了AXI时钟和复位信号的时序。它包含以下部分：
• 第11-2页的时钟和复位要求。

## 11.1 时钟和复位要求
本节给出了实现`ACLK`和`ARESETn`信号的要求。

### 11.1.1 时钟
每个AXI组件使用单一的时钟信号，`ACLK`。所有输入信号都在`ACLK`的上升沿进行采样。所有输出信号的变化都必须在`ACLK`的上升沿之后发生。在主设备和从设备接口之间，输入和输出信号之间不能有组合逻辑路径。

### 11.1.2 复位
AXI协议包含一个单一的活动低电平复位信号，`ARESETn`。复位信号可以异步地被激活，但取消激活必须在`ACLK`的上升沿之后同步进行。在复位期间，以下接口要求适用：
- 主设备接口必须将`ARVALID`、`AWVALID`和`WVALID`驱动为低电平
- 从设备接口必须将`RVALID`和`BVALID`驱动为低电平。

所有其他信号可以被驱动到任何值。

只有在`ARESETn`为高电平之后的一个`ACLK`上升沿，主设备接口才能开始将`ARVALID`、`AWVALID`或`WVALID`驱动为高电平。图11-1展示了复位之后，`ARVALID`、`AWVALID`或`WVALID`可以被驱动为高电平的第一个点。

![[11-1.jpg]]


# 第12章 低功耗接口

本章描述了在进入和退出低功耗状态时的AXI协议时钟控制接口。它包含以下部分：
- 第12-2页的低功耗接口简介
- 第12-3页的低功耗时钟控制。


## 12.1 低功耗接口简介
低功耗接口是数据传输协议的一个可选扩展，目标是两种不同类别的外设：
- 需要一个掉电序列的外设，只有在进入低功耗状态后才能关闭它们的时钟。这些外设需要一个系统时钟控制器的指示来确定何时启动掉电序列。
- 没有掉电序列的外设，可以独立地指示何时可以关闭它们的时钟。

## 12.2 低功耗时钟控制
低功耗时钟控制接口包含以下信号：
- 来自外设的一个信号，指示其时钟何时可以被启用或禁用
- 两个握手信号，用于系统时钟控制器请求退出或进入低功耗状态。

时钟控制接口中的主要信号是`CACTIVE`(clock active)。外设使用这个信号来指示它需要启用其时钟。外设激活`CACTIVE`以指示它需要时钟，系统时钟控制器必须立即启用时钟。外设取消激活`CACTIVE`以指示它不需要时钟。然后，系统时钟控制器可以决定是否启用或禁用外设时钟。

任何时候都可以启用或禁用其时钟的外设可以永久驱动`CACTIVE`为低电平。必须始终启用其时钟的外设必须永久驱动`CACTIVE`为高电平。

对于没有掉电或上电序列的一些外设，这种简单的系统时钟控制器接口就足够了。

对于具有掉电或上电序列的更复杂的外设，只有在系统时钟控制器的请求之后，才会进入低功耗状态。AXI协议提供了一个两线请求/应答握手来支持这个请求：
- `CSYSREQ`：为了请求外设进入低功耗状态，系统时钟控制器将`CSYSREQ`信号驱动为低电平。在正常操作中，`CSYSREQ`是高电平。
- `CSYSACK`：外设使用`CSYSACK`信号来应答低功耗状态的请求和退出低功耗状态。

图12-1显示了`CSYSREQ`和`CSYSACK`之间的关系。

![[12-1.jpg]]

在图12-1的序列开始时，`CSYSREQ`和`CSYSACK`在正常的有时钟操作下都是高电平。在时间T1，系统时钟控制器取消激活`CSYSREQ`，表示请求将外设置于低功耗状态。外设在时间T2通过取消激活`CSYSACK`来应答请求。在T3，系统时钟控制器激活`CSYSREQ`以指示退出低功耗状态，外设在T4激活`CSYSACK`以应答退出。

`CSYSREQ`和`CSYSACK`之间的这种关系是AXI协议的要求。

外设可以接受或拒绝来自系统时钟控制器的低功耗状态请求。当外设通过取消激活`CSYSACK`应答请求时，`CACTIVE`信号的电平指示了请求的接受或拒绝。


### 12.2.1 接受低功耗请求
图12-2显示了当外设接受系统低功耗请求时的事件序列。

![[12-2.jpg]]

在图12-2中，序列在T1开始，此时系统时钟控制器取消断言`CSYSREQ`以请求外设进入低功耗状态。在外设识别到请求后，它可以执行其掉电功能并取消断言`CACTIVE`。然后外设在T3取消断言`CSYSACK`以完成进入低功耗状态。

在T4，系统时钟控制器通过断言`CSYSREQ`开始退出低功耗状态的序列。然后外设在T5断言`CACTIVE`，并在T6通过断言`CSYSACK`完成退出序列。



### 12.2.2 拒绝低功耗请求

图12-3显示了当外设拒绝系统低功耗请求时的事件序列。

![[12-3.jpg]]

在图12-3中，外设通过在应答低功耗请求时保持`CACTIVE`为高电平来拒绝低功耗请求。在那之后，系统时钟控制器必须通过断言`CSYSREQ`来完成低功耗请求的握手，然后才能发起另一个请求。


### 12.2.3 退出低功耗状态
系统时钟控制器或外设可以请求退出低功耗状态并恢复时钟。根据定义，`CACTIVE`和`CSYSREQ`在低功耗状态期间都为低电平，驱动这两个信号中的任何一个为高电平都会启动退出序列。

系统时钟控制器可以通过使能时钟并驱动`CSYSREQ`为高电平来启动从低功耗状态的退出。然后，外设可以执行一个上电序列，在该序列中它驱动`CACTIVE`为高电平。然后它通过驱动`CSYSACK`为高电平来完成退出。

外设可以通过驱动`CACTIVE`为高电平来启动从低功耗状态的退出。然后，系统时钟控制器必须立即恢复时钟。它还必须驱动`CSYSREQ`为高电平以继续握手序列。然后，外设通过在退出低功耗状态时驱动`CSYSACK`为高电平来完成序列。外设可以在需要完成退出序列的所有周期中保持`CSYSACK`为低电平。


### 12.2.4 时钟控制序列总结

图12-4显示了进入和退出低功耗状态的典型流程。

![[12-4.jpg]]

#### 低功耗时钟控制序列

###### 正常时钟操作
1. 系统时钟控制器驱动 `CSYSREQ` 低，请求进入低功耗状态。
2. 外设拒绝或接受请求。
    - 拒绝: 外设保持 `CACTIVE` 高。
    - 接受: 外设执行降功率操作，驱动 `CACTIVE` 低。
3. 系统时钟控制器采样 `CACTIVE`。
4. 系统时钟控制器驱动 `CSYSREQ` 高。
5. 如果外设接受请求，它将驱动 `CSYSACK` 高以完成握手；系统时钟控制器禁用时钟。

###### 低功耗或未锁定操作
1. 外设或系统时钟控制器启动低功耗退出。
2. 外设驱动 `CACTIVE` 高。
3. 系统时钟控制器立即启用时钟。
4. 系统时钟控制器驱动 `CSYSREQ` 高。
5. 外设驱动 `CACTIVE` 高和系统时钟控制器采样到高电平后,外设将驱动 `CSYSACK` 到高电平以完成握手。

## 12.2.5 组合低功耗域中的外设
系统时钟控制器可以在同一低功耗时钟域内组合多个不同的外设。然后，如果遵守以下规则，可以像处理单个外设一样处理时钟域：
- 时钟域的`CACTIVE`信号是时钟域内所有`CACTIVE`信号的逻辑或。这意味着系统时钟控制器只有在所有外设都指示它们可以被禁用时，才能禁用时钟。
- 系统时钟控制器可以使用一个单一的`CSYSREQ`信号，该信号被路由到时钟域内的所有外设。
- 时钟域的`CSYSACK`信号按以下方式生成：
  - `CSYSACK`的下降沿发生在所有外设的最后一个下降沿发生时
  - `CSYSACK`的上升沿发生在所有外设的最后一个上升沿发生时


